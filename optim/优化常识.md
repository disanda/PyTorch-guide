## optim的一些理论基础
### 1.训练过程
神经网络的训练过程如下：

- 做一个神经网络用于拟合目标函数
- 做一个真实值和目标函数值直接估计误差的损失函数，
- 用损失函数值前向输入值求导，
- 再根据导数的反方向去更新网络参数(x),目的是让损失函数值最终为0.

### 2.专有名词
- SGD
>在第四步中，参数的更新就是pytorch中的optim(优化过程)，现在都是随机梯度下降，即每次更新是通过随机抽样来更新参数(总数的一小部分，简称为一个batch)。

公式:
![](http://latex.codecogs.com/gif.latex?x_{t+1}=x_t+\Delta{x_t})  (1)

为此，需要设置一个学习率，保证每个batch学习更新的参数足够小。

- learning rate

公式:
![](http://latex.codecogs.com/gif.latex?\Delta{x_t}=-\eta{g_t})  (2)

其中eta就是学习率, 选择适当的学习率才能优化到合适的目标.

学习率过高: 1.目标发散

学习旅过低: 2.更新较慢

### 3.优化方法

#### 3.1.Hessian matrix

公式:
![](http://latex.codecogs.com/gif.latex?\Delta{x_t}=H^{-1}_{t}g_{t})  (3)

其中的H是一个Hessian矩阵, 通过迭代次数t,计算出的二阶导数矩阵，这个方法计算量过于庞大，所以在较大的模型中不太现实。

#### 3.2. Momentum

和学习率相关的就是动量 Momentum, 这个变量是前期梯度的积累，当前梯度和前期梯度方向相同时，梯度更新会加速。当前梯度和前期梯度方向不同时，梯度更新会减缓。这样在转弯的时候，震荡就会减轻。

公式:
![](http://latex.codecogs.com/gif.latex?\Delta{x_t}=\rho\Delta{x_{t-1}}-\eta{g_t})  (4)

其中的rho就是动量值，如果为0.9，就代表其每次都保留上一次梯度的0.9

#### 3.3.Adagrad

对过去每个维度所有时间的梯度求l2 norm,作为分母，分子是一个全局学习率. 每个维度有自己的学习率，梯度变化大的学习率小，梯度变化小的学习率就大. 让不同梯度变化的维度有与之适应的学习率，这是一个不错的退火策略(annealing)。

公式:
![](http://latex.codecogs.com/gif.latex?\Delta{x_t}=-\frac{\eta}{\sqrt{\sum\nolimits_{\tau=1}^tg^{2}_{\tau}}}g_t)  (5)

这个方法的毛病就是初始训练较为敏感，如果某一维度初始训练时梯度梯度很大，在剩下的训练学习率就会被调整到很低，虽然可以提高全局学习率来抵抗这个衰减，但是整体的学习率依然是在降低的，最终学习率为0并停止训练。

#### 3.4. AdaDelta

这个方法就是为了解决超参选择时学习率持续衰减的问题。之前的方法通过Hessian矩阵来估计学习率，但是需要计算全局的二阶导数，这个计算量太大了，用一个对角线矩阵来近似Hessian矩阵。这个对角线矩阵可以通过让模型一次前向传播和一次后向传播来计算。

![](http://latex.codecogs.com/gif.latex?\Delta{x_t}=\frac{1}{|diag(H_{t})|+\mu}g_{t})  (6)



### Reference
[1]. AdaDelta:AN ADAPTIVE Learning Rate Method, Matthew D. Zeiler, 2012
